Hey, so I'm documenting my thoughts regarding nocodo, this product that I am ideating. Now nocodo is a fairly complex piece of software, which is why I think documenting my thoughts just free-flowing as they are in my head is probably a better idea. This is why I'm recording my voice and seeing how it will go.

The basic idea of nocodo is that it takes a lot of the structural part of building software - as we are when we are building with vibe coding or AI-generated coding - it takes a lot of those structural elements, the boring stuff, to create good quality software. It issues those prompts depending on the context of a project, step by step.

It uses tools like Claude Code, Gemini CLI, or OpenAI Codex CLI, or Qwen Code CLI - any of these CLI tools. It uses them, but it uses them not to wrap over the CLI tools. Rather, it runs inside the CLI tools because nocodo is many parts. One of those parts is itself a command line tool. So Claude Code, for example, could easily just call nocodo, and nocodo the CLI tool would allow Claude Code to have an overview of how to start this project because the user is interacting on a web browser on the other side and there is this whole set of communication going back and forth.

So how does that communication work? Let's break this down.

First of all, there is a client-side application. Let's call these client-side applications. The client-side application is basically some form of a GUI application. Initially it's a web application, and there's a tiny binary running on a desktop.

The tiny binary takes credentials. We support - let's initially say Scaleway, but we could also support Digital Ocean in the future, etc. - cloud providers. So we support minimal cloud provider. Let's say Scaleway to start with, and we use API calls to create a server. Of course, to create a server we need API access to it, and there come API keys. So these secrets are managed directly on the client side, on the computer of the user.

Now the user interacts with the web interface, and there will be two web interfaces I'm going to be talking about. We can also merge them into one, but let's stick with the idea of two web interfaces.

This web interface is for the client side only. So this is the key management, this is the access management, secrets management - all of that. Think of it as Vault. This web interface communicates with - on the desktop there is a small binary running. The binaries - all binaries across nocodo, everything is written in Rust. This particular binary manages the key data, the sensitive data. It stores it into a local SQLite database, encryption at rest, password-based.

And then the web application, which is the accompanying web application, first of all needs authentication. So the authentication goes through nocodo.com, which is the owner of all of this. As in the owner business, let's say the business owner. Through nocodo.com, users will have to first authenticate. So that will be normal - let's say an account with nocodo.com. Okay, so nocodo.com will create... absolutely later, no relationship to this thought process documentation at all right now.

So let's say nocodo.com allows users to be simply created either through social login or through normal email/password - whatever it is doesn't really matter, some kind of authentication. So the user authenticates on their browser. That authentication goes back to this binary that is running on the user's machine. This binary is hosting a web interface. The web interface is visible on the browser, where now once the user is logged in, they can go ahead and they can add supported service providers' API keys.

So once we are done adding, immediately we trigger creation of a Linux server on Scaleway. Let's say a typical 4GB-8GB memory machine with maybe three or four virtual CPUs - not too big, not too large, just modest size developer machine. And what we do is we start with Ubuntu, we update, we harden the server, and then we immediately install.

Now comes the next part of nocodo. The next part of nocodo is now a manager application. This manager application is a daemon. Now this daemon runs on this Linux - let's say this Linux server is called the operator. It runs on the operator as a daemon, and it allows orchestrating both the operator and everything else. So it's basically think of it as like some kind of Ansible and Terraform mixed together. It's a bunch of scripts all baked in. It's also a Rust binary. It's a daemon. It also opens an API for yet the next web app. We'll come to this web app. But yes, there's the daemon.

This server called the operator - this is the Linux server - it also hosts another web app, and it also hosts a nocodo CLI. So here comes the final part. The final Rust binary is a nocodo CLI.

This CLI interacts with the daemon. The daemon interacts with the web app. That's how the communication flows. And the daemon is also interacting with - if we recall, there is the app that is running on the desktop of the user. So there is a binary running on the desktop of the user. There's a binary now running on the Linux machine we call operator. And these two binaries - the daemon binary on the Linux and the binary that is on the client side - they communicate with each other. What communication protocols, etc. need to be kind of discussed later on, figured out later on. But let's just say this is the overview.

Okay, so now this is the overall architecture. The daemon that is running on Linux operator communicates with the web app. It hosts itself. The operator also hosts the web app. This web app basically gives you a Lovable-like interface. So think of an interface where you could chat with AI and you could build software. So this is that web interface because this has direct access on that Linux machine to the daemon. It has the CLI code generation tools, so Claude Code, Gemini - all of that is installed. Entire development stack is installed. All of that is managed, like I said, by the daemon itself, and it also has access to nocodo the CLI.

So what is the job of the nocodo CLI? Nocodo CLI just guides per project the spec building. Like it basically manages what the guardrails of a good project are - good practices. So understand the user - so ask Claude or whichever CLI tool we are using to break down the user's request to verify with the current project structure.
