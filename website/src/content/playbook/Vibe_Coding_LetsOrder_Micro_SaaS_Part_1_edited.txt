Good morning! Today, we'll walk through the entire process of vibe coding the SaaS product I launched last week. I'm still refining how to make this video compact yet useful, so it might be a bit lengthy—but that's okay because there's a lot to cover.

This is my first attempt at fully launching a product. There's a big difference between weekend experiments or small applications built with tools like Lovable, where you mostly get a UI, and building a complete full-stack product. What I'm talking about here is creating a full-stack micro-SaaS (software as a service), designed as a B2B solution. While this particular idea is just one of many I'm exploring, the focus here is on the workflow. I'm continuously refining this workflow, and I believe I've developed something that works well.

My approach combines several elements, including voice annotations where I describe the user flow or data flow of a project. I then ask AI tools like Claude or Gemini to clean up these notes. While you can use web-based tools, terminal-based tools are often better when building software projects because you'll inevitably need to use the terminal anyway—whether for testing, running systems like Node/NPM, Python, Ruby, or connecting to databases. Starting in the terminal early clears potential roadblocks and makes it easier to focus on building features for the minimum viable product (MVP).

I'm not suggesting you build everything at once. The principles of software engineering, product development, and startups still apply even when using AI to generate code. These principles serve as anchors and grounding rules. AI simply helps generate most of the code, especially during the MVP stage, enabling faster iteration.

Let's look at the product I created: Let's Order. I've secured the domain letsorder.app, and as you can see from the screenshots, it's live. People have already tested the demo. The product includes an admin side, a menu side, a backend, and full-stack deployment.

When launching the demo, I might encounter bugs during this recording—that's completely fine. This is live software that hasn't been thoroughly tested yet. Friends have already reported glitches, which is expected. The goal here isn't to present perfect code but to demonstrate how I built a fully functioning full-stack micro-SaaS without writing or even reviewing the code myself. It's deployed, live, and people are already testing it.

For the demo, the user credentials are: manager@example.com with password 123. These were generated by the LLM and can be changed later. I've already cleaned the data, using a data-cleaning script that runs periodically (though I should double-check if it's working properly). With a public demo, people inevitably test boundaries—sometimes with vulgar language—but that's to be expected.

The application includes table management. For example, this restaurant (one I personally enjoy in Kolkata) has a link to its Google Maps location. You can create and edit tables—though I'll admit I'm not entirely sure how restaurants typically name their tables. Each table has a QR code generated by the backend. All data, authentication, and management are handled by the backend.

The QR code links to a specific URL. If you scan this code (you can pause the video to try), you'll be directed to a unique URL. For example, m.letsorder.app versus a.letsorder.app—'a' for admin and 'm' for menu. These are separate applications, which we'll explore to give you a complete overview.

Now, let's discuss the prompting process. There's no single prompt—this is vibe coding. The term, coined by someone from OpenAI's original idea team, refers to trusting large language models to do the right thing without scrutinizing every line of code. This is similar to trusting a skilled developer on your team—you rely on their expertise while understanding they might make mistakes. When using AI for code generation, you also face constraints, primarily the limitations of the large language models themselves.

Don't expect AI to accomplish everything humans have developed over 40-50 years of software engineering. We still have a mess of programming languages and frameworks. AI gives us amazing power, particularly in realizing the long-pursued dream of non-technical people building software. I've chased this idea for years—I even own the domain nocodo.com (from 2013)—because I believe we're finally approaching a reality where people can build software projects without knowing traditional software engineering.

The structure required for effective prompting isn't overwhelming. Let me show you my starting point: the project overview. This documentation, generated from my prompts, is available in the GitHub repository. While the original prompts aren't preserved, the documentation captures the essence of what I created.

I began with a simple project overview:
- Let's Order: A complete menu management, browsing, and ordering app for restaurants and guests.
- Two main user types: restaurant managers and guests.
- Guests don't need to log in; they see the menu, select items, modify their order, and place it.
- Restaurant managers create restaurants after email/password registration.
- Restaurant data, including menus, can only be viewed or updated after authentication.

Key features include:
- Menus accessible via QR codes on tables, linking to URLs like m/[unique-restaurant-and-table-code].
- Each table/restaurant combination has a unique URL, automatically tracking order origins.
- Future possibilities include different menus for different times of day or seasonal offerings, ensuring customers only see relevant options.

For restaurant registration:
- Users authenticate via email/password (or potentially phone number).
- Two managers are required per restaurant.
- Required information includes restaurant name, address, establishment date, picture, phone number, and Google Maps link.

Menu management allows:
- Adding, editing, and removing menu items.
- Categorizing items.
- Setting prices and descriptions.
- Managing availability.

Technical preferences:
- Rust for the backend (despite being potentially overkill) because I appreciate strongly typed APIs. The combination of Rust and TypeScript reduces error possibilities.
- Solid.js for the restaurant management application (preferred over React for its smaller size and built-in router and state management).
- Tailwind CSS for styling.
- Astro for the marketing application (ideal for content-focused websites).

The database choice was simple — I used a straightforward solution that integrates well with the Rust backend.

My workflow typically involves:
1. Creating a high-level project overview.
2. Asking the AI to generate clarification questions to ensure I've considered all aspects.
3. Using the refined requirements to generate specific tickets/issues for development.

This approach helped me build and deploy this 19,000-line codebase (7,300 lines of Rust, 3,000 lines of TypeScript, and 6,500 lines of TSX) in just 12 days. For context, this would typically take a developer 2-2.5 months of manual coding.

The development process revolves around GitHub issues and pull requests. Each feature is implemented in a separate branch, tested, and then merged into the main branch when ready. This structured approach allows for efficient development and easy tracking of progress.

This video is the first in a series focusing on this project. My goal is to motivate more people — especially non-engineers—to start experimenting. Begin with static websites, then progress to dynamic ones. Within a month, you could be creating and launching full-fledged MVPs. I'm hosting sessions this week and in the coming weeks—check my personal website for links to my Luma sessions.

Thank you for watching!
